## [ZooKeeper:分布式应用协调服务]()
- [设计目标]()
- [数据模型和层次性的命名空间]()
- [节点和临时节点]()
- [条件更新和检测]()
- [担保]()
- [简单的API]()
- [实现]()
- [使用]()
- [性能]()
- [可靠性]()
- [ZooKeeper项目]()

-- 
### [ZooKeeper:分布式应用协调服务]()
ZooKeeper是一个分布式的、开源的分布式应用协调服务。他提供一组简单的原语，分布式应用可在其上构建同步、配置管理、分组和命名的高级版服务。他被设计的易于编程，和类似文件系统的风格的数据模型。其运行在java上并提供Java和C的绑定。

协调服务是出了名的难以正确处理，极易出错例如冲突和死锁。ZooKeeper的动机是减轻分布式应用的实现从零开始协调服务责任。

### [设计目标](#sc_designGoals)
**ZooKeeper非常简单**，Zookeeper允许分布式处理通过共享层次性的命名空间来协调服务，其组织类似于一个标准的文件系统。命名空间包含注册的数据在ZooKeeper中称作znodes，类似于文件和目录。不像典型的文件系统设计用来存储，ZooKeeper数据保存的内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟的数据。

ZooKeeper实现溢价高性能，高可用性，严格有序的访问。在性能方面的优势使它可以应用在大型的，分布式系统。可靠性方面，它从一个单一的故障点。严格的顺序是指在客户端可以实现复杂的同步原语。

**可复制**，像它所协调的分布式进程，ZooKeeper自身复制到一组主机作为一个整体。

ZooKeeper 服务

![image](http://zookeeper.apache.org/doc/r3.4.6/images/zkservice.jpg)

组成ZooKeeper服务的服务器都必须相互知道对方的存在。它们在内存映像中保持状态，以及在持久存储中保存事务日志和快照。只要大部分的服务器可用，ZooKeeper服务就是可用的。

客户端连接到一个单一的服务器上。客户端管理一个TCP连接通过它来发送请求，获取应答，获取观察事件和发送心跳。如果TCP连接到服务器中断，客户端可以连接到不同的服务器。

**有序**，ZooKeeper给每次更新标记一个数字来反映ZooKeeper事务的次序。随后的操作可以使用这个次序实现更高级别的抽象，如同步原语。

**快速**，它特别快，在“读”的工作负载。ZooKeeper应用程序运行在数千台机器上，它们在读操作多于写操作中工作的很好，其比例大概10:1。

### 数据模型和层次性命名空间
ZooKeeper提供的命名空间更像是一个标准的文件系统。一个名字是一个（/）分隔的路径元素的序列。ZooKeeper的命名空间节点是路径标识。

ZooKeeper的层次命名空间

![image](http://zookeeper.apache.org/doc/r3.4.6/images/zknamespace.jpg)

### 节点和临时节点

不像标准的文件系统，每一个节点在ZooKeeper命名空间中可以有为其分配的数据以及子节点。它就像有一个文件系统，允许是一个文件，也可以是一个目录。（ZooKeeper被设计用来储存协调数据：状态信息，配置，位置信息等，因此，数据存储在每个节点通常是很小的，在字Kb节范围。）我们使用术语znode更清楚的来谈论ZooKeeper中的数据节点。

znodes保存一个数据结构，包括数据的变化，版本号和时间戳，ACL的变化，允许缓存验证和协调更新。每次znode的数据变化，版本号的增加。例如，每当客户检索数据时，它也接收到数据的版本。

数据存储在一个命名空间中的每个节点的读写是原子性的。在一个znode上的读操作将获得所有分配的数据，写操作将替换所有数据。每个节点都有一个访问控制列表（ACL），限制谁可以做什么。

ZooKeeper也有临时节点的概念。这些znodes存创建它们的Session当中。当Session结束znode被删除。当你想实现临时节点是有用的[待定]。

### 条件更新和观察

ZooKeeper支持watches概念。客户端可以在xnodes上设置watch，当znodes改变时watch会被触发并移除。当watch被触发客户端接收到一个分组来说明znode已改变。如果客户端和一个ZooKeeper服务器之间的连接被打破，客户端将收到一个本地通知。这些可以用来[待定]。

### 担保
ZooKeeper非常快，非常简单。虽然它的目标是为建设更为复杂的服务，例如同步，它提供了一系列的保证。这些包括：

- **序列一致性** - 一个客户端的更新将放到他发送的序列当中。
- **原子性** - 更新或成功或失败，没有其他结果。
- **单一的系统视图** - 无论客户端连接到那台服务的服务器，客户端都会看到同样的视图。
- **可靠性** - 一旦被应用的更新，它就会保持直到有客户端再次更新。
- **及时** - 在一定时间范围内保证系统的客户视图是最新的。
关于这方面的更多信息，以及他们如何可以使用，参见[待定]。

### 简单的API
ZooKeeper的设计目标之一就是提供一个简单的编程接口。其结果是，它只支持这些操作：

create ： 在树的位置创建一个节点

delete ： 删除一个节点

exists ： 测试阶段是否存在

get data ： 从节点读取数据

set data ：　向节点写入数据

get children ： 接收节点的子节点列表

sync ： 等待数据的传播

对这些更深入的讨论，以及他们如何可以用来实现更高层次的操作，请参阅[待定]

### 实现
[ZooKeeper组件]()展示了ZooKeeper服务更高级别的组件。随着请求处理器的例外，每个组成ZooKeeper服务的服务器上复制自己的每个组件的副本。

ZooKeeper组件

![image](http://zookeeper.apache.org/doc/r3.4.6/images/zkcomponents.jpg)

复制的数据库是包含整个数据树的内存数据库中的一个。
更新记录到磁盘的可恢复性，和写入序列化到磁盘之前，将其应用于内存中的数据库。

每一个ZooKeeper服务器都为客户端提供服务，客户端连接到一个服务器提交请求。读取请求从每个服务器数据库的本地副本中提供服务。要求更改服务的状态，写请求，由协议协议处理。

协议的一部分，所有写请求的客户端被转发到一个单一的服务器，称为*Leader*。其余的ZooKeeper服务器称为*followers*，接收来自leader的提议和消息传递。消息传递层负责对故障和更换领导人的追随者与领导者同步。

ZooKeeper使用自定义的原子通讯协议。由于信息层是原子的，ZooKeeper可以保证本地副本不发散。当Leader者收到一个写请求时，它会计算系统的状态是什么时候写的是被应用，并把它转换成一个捕获这个新状态的事务。

### 使用
ZooKeeper的编程接口是故意做的简单。有了它，你可以实现更高层次的操作，如同步原语，组成员，所有权，等。一些分布式应用程序用它来：[待定：从白皮书和视频演示添加使用。]的更多信息，参见[待定]

### 性能
ZooKeeper被设计成高性能的。是否为这样，对于雅虎的开发团队的研究证明了这点。（如下图）他在读操作远多于写操作的应用中性能非常理想，自写涉及同步服务器的状态（读多写的是协调服务典型案例）。

ZooKeeper Throughput as the Read-Write Ratio Varies

![image](http://zookeeper.apache.org/doc/r3.4.6/images/zkperfRW-3.2.jpg)

上图[ZooKeeper Throughput as the Read-Write Ratio Varies]()是运行在商河2Ghz Xeon处理器和2个SATA 15k RAM设备上的ZooKeeper（release 3.2）吞吐量图。

> **Note** 3.2版本的读写性能提高~ 2X相比之前的3.1版本。

基准也表明它是可靠的[Reliability in the Presence of Errors]()显示如何部署应对各种故障的响应。在图中标注的事件如下：

+ 1.一个follower的失败和恢复
+ 2.另一个follower的失败和恢复
+ 3.leader失败
+ 4.两个follower失败和回复
+ 5.其他leader失败

### 可靠性
为了展示系统在发生故障的行为我们跑了7台ZooKeeper服务。我们和以前一样运行了相同的饱和基准，但是这个时候我们将写的百分比保持在30%，这是我们预期的工作负载的保守比率。

Reliability in the Presence of Errors

![image](http://zookeeper.apache.org/doc/r3.4.6/images/zkperfreliability.jpg)

从这张图中，有几个重要的意见.第一，如果follower失败和恢复的很快，ZooKeeper能够维持高吞吐量尽管有失败。但也许更重要的是，领导选举算法允许系统恢复快，以防止吞吐量大幅下降。在我们的观察中，ZooKeeper需要小于200ms选出新leader。第三，follower恢复，ZooKeeper能够再次提高吞吐量，一旦他们开始处理请求。

### ZooKeeper项目
ZooKeeper已成功地应用在许多工业应用。在雅虎，作为协调和故障恢复服务！消息代理，这是一个高度可扩展的发布订阅系统管理成千上万的主题的复制和数据传递。它是用于雅虎的抓取服务！履带，在那里它还管理故障恢复。一些雅虎！广告系统也用它来实现可靠的服务。

所有用户和开发人员都被鼓励加入社区并贡献他们的专业知识。在[Zookeeper Project on Apache ](http://zookeeper.apache.org/)查看更多信息。





